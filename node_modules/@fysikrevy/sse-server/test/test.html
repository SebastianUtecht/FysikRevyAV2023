<!doctype html>
<html>
    <head>
        <title></title>
        <meta charset="utf-8" />
        <style type="text/css" >
         body {
             font-family: "Trebuchet MS", sans-serif;
             font-size: smaller;
             color: #000d;
         }
         
         section {
             background: #ffdab945;
             box-shadow: 0px 0px 15px lightgrey;
             max-width: 50rem;
             margin-right: auto;
             margin-left: auto;
             padding-left: 16rem;
             padding-bottom: 3px;
             padding-right: 3px;
         }

         h3 {
             margin-left: -15.8rem;
         }

         h4 {
             margin-left: -15.8rem;
             margin-right: .3rem;
             margin-bottom: 00%;
             margin-top: 3px;
             display: block;
             width: 15.5rem;
             height: 0px;
         }

         .outgroup {
             display: flex;
             align-items: baseline;
             transition: all .3s ease-in, max-height 3s .3s ease-out;
             max-height: 1.2em;
             margin-bottom: 2px;
         }

         .outgroup:hover {
             flex-direction: column;
             align-items: flex-start;
             background: #fff9;
             box-shadow: 0px 0px 10px lightGrey;
             padding: 3px;
             margin-top: -3px;
             margin-left: -3px;
             max-height: 100000px;
             overflow-y: hidden;
             transition:  max-height 3s .3s ease-in;
         }
                  
         .progress {
             display: inline-block;
             min-width: 8em;
             background: #aaa9;
             box-shadow: 0px 0px 10px lightGrey;
             margin-right: 1em;
             color: white;
             text-align: center;
         }

         .progress.setup, .progress.loading {
             /* color: #00bfff;
                box-shadow: 0px 0px 10px #00bfff99; */
             background: #00bfff99;
         }

         .progress.loaded {
             /* color: lime;
                box-shadow: 0px 0px 10px #00ff0099; */
             background:  #00ff0099;
         }

         .progress.error {
             background: #ff000099;
         }
         
         .progress.warning {
             background: #ffc00099;
         }
         
         /* .outtext {
            height: 1em;
            overflow: hidden;
            vertical-align: bottom;
            } */

         .outtext p {
             margin: 0px;
             display: none;
         }

         .outtext :last-child {
             display: initial;
         }

         .outgroup:hover .outtext p {
             display: block;
             font-family: "Consolas", "Monarco", "Terminal", monospace;
             white-space: pre;
         }
         
        </style>
    </head>
    <body>
        <template id="outgroup" >
            <div class="outgroup" >
                <span class="progress" >&nbsp;</span>
                <span class="outtext" > </span>
            </div>
        </template>
        <script type="text/javascript" >
function hashString(e) {
    for(var r=0,i=0;i<e.length;i++)r=(r<<5)-r+e.charCodeAt(i),r&=r;
    return r;
};
function getNewOutGroup() {
    var outNode = document.importNode(
        document.querySelector("#outgroup").content, true)
        .firstElementChild;
    outNode.setStatus = function setStatus(status) {
        var bar = outNode.querySelector('.progress');
        if (!outNode.knownStates)
            outNode.knownStates = new Set([status]);
        else {
            bar.classList.remove(...outNode.knownStates);
            outNode.knownStates.add(status);
        }
        bar.classList.add(status);
    };
    outNode.getStatus = function getStatus() {
        if (outNode.knownStates != undefined) {
            var bar = outNode.querySelector(".progress");
            for (const state of outNode.knownStates) {
                if (bar.classList.contains(state))
                    return state;
            }
        }
        return "none";
    };
    outNode.setTitle = function setTitle(title) {
        outNode.querySelector('.progress').textContent = title;
    };
    outNode.log = function outNodeOut(line) {
        /* if (typeof line != "string")
           throw new TypeError("OutNode log only accepts strings.");
        */
        let p = document.createElement("p");
        p.textContent = line;
        outNode.querySelector('.outtext').appendChild(p);
    };
    outNode.nextFuncs = [function signalNext() {
        outNode.addNext = function bounceNext(func) {
            func();
        };
    }];
    outNode.addNext = function addNext(func) {
        // if (outNode.nextCalled)
        //     func();
        // else
            outNode.nextFuncs.push(func);
    };
    outNode.next = function callNext() {
        outNode.nextFuncs.forEach( e => {
            e();
        } );
        outNode.nextFuncs = [];
    };
    return outNode;
};
function xhrEventListeners(xhr, outT, endFunction, errorFunction) {
    if (typeof endFunction != "function")
        endFunction = (() => {});
    if (typeof errorFunction != "function")
        errorFunction = (() => {});
    
    xhr.addEventListener("readystatechange", () => {
        switch (xhr.readyState) {
        case 1:
            outT.log("Request state is OPENED");
            break;
        case 2:
            outT.log("Request state is HEADERS_RECIEVED");
            outT.log("Response code: " + xhr.status + " " + xhr.statusText);
            outT.log("Readable headers:");
            xhr.getAllResponseHeaders().trim().split(/[\r\n]+/)
                .forEach( e => outT.log("    " + e) );
            break;
        case 3:
            outT.log("Request state is LOADING");
            break;
        case 4:
            outT.log("Request state is DONE");
            break;
        }
    }, false);
    xhr.addEventListener("loadstart", () => {
        outT.setStatus("loading");
    }, false);
    xhr.addEventListener("load", () => {
        // outT.setStatus("loaded");
        if (xhr.status < 300)
            endFunction();
        else if (xhr.status >= 400) {
            outT.setStatus("error");
            outT.log(xhr.status + " " + xhr.statusText);
            errorFunction();
        }
    }, false);
    xhr.addEventListener("error", e => {
        outT.setStatus("error");
        outT.log(e.type);
        console.log(e);
        errorFunction();
    }, false);
    xhr.addEventListener("timeout", () => {
        outT.setStatus("error");
        outT.log("Timeout after " + xhr.timeout + " miliseconds.");
        errorFunction();
    }, false);
};
var urlLoc = "http://localhost/";
var urlBase = urlLoc + "test/";

var getTestDiv = document.createElement("section");
getTestDiv.id = "get-test";
getTestDiv.innerHTML = "<h3>GET tests</h3>";
document.body.appendChild(getTestDiv);

var getTest = {
    testingExts: [],
    results: [],
    runTest: function(ext, outT, contentTest) {
        if (this.testingExts.includes(ext) )
            return;
        else
            this.testingExts.push(ext);

        if (!(contentTest instanceof Function))
            contentTest = function defaultTest(test, xhr) {
                outT.setStatus("loaded");
            };

        /* var tPro = document.createElement("span");
           tPro.classList.add("progress", "setup");
           tPro.textContent = ext + ": setup";
           outT.appendChild(tPro); */
        
        var xhr = new XMLHttpRequest();
        xhrEventListeners(xhr, outT, () => {
            this.acceptResult(ext, hashString(xhr.responseText), outT);
            contentTest(this, xhr);
        }, () => {
            this.acceptResult(ext, NaN);
        });
        xhr.timeout = 10000;
        xhr.open("GET", urlBase + "test" + ext);
        xhr.send();
    },
    acceptResult: function(ext, res, outT) {
        var ci = this.testingExts.indexOf(ext);
        if (ci < 0) {
            console.warn("getTest.acceptResult: Got result from unknown test: "
                         + ext + "   Adding test to list.");
            this.testingExts.push(ext);
            ci = this.testingExts.length - 1;
        }
        if (this.results[ci] !== undefined) {
            console.warn("getTest.acceptResult: Got test result for "
                         + "already completed test: " + ext
                         + "  Replacing result.");
        }

        this.results[ci] = res;
        if (outT !== undefined)
            outT.log("Hash of " + urlBase + "test" + ext + ": " + res);

        /* 
           if (this.results.length == this.testingExts.length
           && this.results.every( e => typeof(e) == "number" )
           ) {

           // Wait a bit, to see if more tests show up.
           var cLength = this.results.length;
           console.log("poing", cLength, this.results.length);
           window.setTimeout( () => {
           if (cLength != this.results.length) return;

           if (this.results.every( e => e == this.results[0] )) 
           getTestDiv.append("verified");
           else
           getTestDiv.append("failed");

           this.results = [];
           }, 600);
           } */
    }
};

getTestDiv.innerHTML += "<h4>Download .html file</h4>";
let htmlOut = getNewOutGroup();
htmlOut.setTitle(".html");
getTestDiv.append(htmlOut);
var tl;
getTest.runTest(".html", htmlOut, function htmlTest(test, xhr) {
    let a = xhr.responseText.substring(0,xhr.responseText.indexOf("\n"));
    let b = "<!doctype html>";
    tl = xhr.responseText.length;
    htmlOut.log("Total length: " + tl);
    htmlOut.log("Document start is \"" + a + "\", expected \"" + b + "\"");
    if (!a.startsWith(b)) {
        htmlOut.setStatus("error");
        return;
    }
    a = xhr.responseText.substr(-33);
    b = "<!-- sse-server test script -->";
    htmlOut.log("Document end is \"" + a + "\", expected \"" + b + "\"");
    if (!a.startsWith(b)) {
        htmlOut.setStatus("error");
        return;
    }
    htmlOut.log("OK");
    htmlOut.setStatus("loaded");
    htmlOut.next();
});
// setTimeout(() => {
// getTestDiv.innerHTML += "<h4>Extension aliasses</h4>";
htmlOut.addNext(() => {
    getTestDiv.appendChild(document.createElement("h4")).textContent = "Extension aliases";
    [".remote", ".left", ".right", ".mid"].forEach( e => {
        
        let aliasOut = getNewOutGroup();
        aliasOut.setTitle(e);
        aliasOut.addNext(partTest);
        getTestDiv.append(aliasOut);
        getTest.runTest(e, aliasOut, function aliasTest(test, xhr) {
            let rightHash = test.results[test.testingExts.indexOf(".html")];
            let curHash = test.results[test.testingExts.indexOf(e)];
            aliasOut.log( "Hash of " + urlBase + "test" + e + ": " + curHash
                          + " (" + rightHash + " expected)");
            if (curHash == rightHash) {
                // aliasOut.log("Done");
                aliasOut.setStatus("loaded");
                if (aliasOut.parentElement.querySelectorAll(".progress").length
                    == aliasOut.parentElement.querySelectorAll(".loaded").length
                   )
                    aliasOut.next();
            } else {
                aliasOut.setStatus("error");
            }
        });
    });
});
// }, 2000);

var partOut = getNewOutGroup();
var partTest = function partTest() {
    partTest = (() => {});
    getTestDiv.innerHTML += "<h4>Partial get</h4>";
    partOut.setTitle(".html (parts)");
    getTestDiv.appendChild(partOut);

    partOut.log("Total length: " + tl);

    let xhr1 = new XMLHttpRequest();
    xhr1.open("GET", urlBase + "test" + ".html");
    xhrEventListeners(xhr1, partOut);
    let rh1 = "bytes=" + 0 + "-" + 14;
    partOut.log("Setting range header to \"" + rh1 + "\"");
    xhr1.setRequestHeader("range", rh1);
    xhr1.addEventListener("load", () => {
        if (xhr1.status >= 400) {
            partOut.log(xhr1.status + " " + xhr1.statusText);
            partOut.setStatus("error");
        } else {
            partOut.log("Response length: " + xhr1.responseText.length
                        + " (of " + tl + ")");
            if (xhr1.responseText.length == 15) {
                let a = "<!doctype html>";
                partOut.log("First 15 bytes: \"" + xhr1.responseText
                            + "\" (\"" + a + "\" expected)");
                if (xhr1.responseText.localeCompare(a) == 0) {
                    xhr1.open("GET", urlBase + "test" + ".html");
                    let rh = "bytes=" + (tl-32) + "-" + (tl-1);
                    partOut.log("Setting range header to \"" + rh + "\"");
                    xhr1.setRequestHeader("range", rh);
                    xhr1.addEventListener("load", () => {
                        partOut.log("Response length: "
                                    + xhr1.responseText.length + " (of "
                                    + tl + ")");
                        a = "<!-- sse-server test script -->";
                        partOut.log("Last 32 bytes: \"" + xhr1.responseText
                                    + "\" (\"" + a + "\" expected)");
                        if (xhr1.responseText.startsWith(a)) {
                            // partOut.log("OK");
                            partOut.setStatus("loaded");
                            partOut.next();
                        } else
                            partOut.setStatus("error");
                    }, false);
                    xhr1.send();
                } else
                    partOut.setStatus("error");
            } else if (xhr1.responseText.length == tl) {
                if (hashString(xhr1.responseText)
                    == getTest.results[getTest.testingExts.indexOf(".html")]
                   ) {
                    partOut.setStatus("warning");
                    partOut.log("Got entire file in stead of file part");
                    partOut.next();
                } else {
                    partOut.setStatus("error");
                    partOut.log("Unexpected response content");
                } 
            } else {
                partOut.setStatus("error");
                partOut.log("Unexpected response length");
            }
        }
    }, {once: true} );
    xhr1.send();
};

var subTestSec = document.createElement("section");
subTestSec.innerHTML = "<h3>Subtitle conversion tests</h3>";
partOut.addNext(() => {
    document.body.appendChild(subTestSec);
});

function subTest(extn, srtOut) {
    subTestSec.appendChild(document.createElement("h4"))
        .textContent = "." + extn + " to .vtt conversion";
    subTestSec.appendChild(srtOut);

    let xhr = new XMLHttpRequest();
    xhr.open("GET", urlBase + extn + ".vtt");
    xhr.addEventListener("load", () => {
        srtOut.log(xhr.status + " " + xhr.statusText);
        if (xhr.status < 400) {
            srtOut.log("RECIEVED CONTENT: ----------------");
            srtOut.log(xhr.responseText);
            srtOut.log("END RECIEVED CONTENT -------------");
            srtOut.log("content-type: "+ xhr.getResponseHeader("content-type"));
            let xhr2 = new XMLHttpRequest();
            xhr2.open("GET", urlBase + "true-" + extn + ".vtt");
            xhr2.addEventListener("load", () => {
                srtOut.log("Comparing with " + urlBase + "true-" + extn + ".vtt");
                if (xhr2.status < 400) {
                    srtOut.log("content-type: "+ xhr2.getResponseHeader("content-type"));
                    if (xhr2.responseText.startsWith(xhr.responseText)) {
                        srtOut.setStatus("loaded");
                        srtOut.log("OK");
                    } else {
                        srtOut.setStatus("warning");
                        srtOut.log("Failed");
                    }
                } else {
                    srtOut.setStatus("warning");
                    srtOut.log(xhr2.status + " " + xhr2.statusText);
                }
            });
            xhr2.send();
        } else {
            srtOut.setStatus("error");
            srtOut.log(xhr.status + " " + xhr.statusText);
        }
        srtOut.next();        
    });
    xhr.addEventListener("error", e => {
        srtOut.setStatus("error");
        srtOut.log(e.type);
    });
    srtOut.log("Requesting " + urlBase + "srt.vtt");
    srtOut.setStatus("loading");
    xhr.send();

};

var srtOut = getNewOutGroup();
srtOut.setTitle(".srt");
partOut.addNext(() => {subTest("srt", srtOut);});
var assOut = getNewOutGroup();
assOut.setTitle(".ass");
partOut.addNext(() => {subTest("ass", assOut);});

function Mediate(func) {
    this.hesitance = 0;
    this.eagerness = 0;
    this.set = function setMediate() {
        this.hesitance++;

        console.log(func);
        return (() => {
            this.eagerness++;
            console.log("ping", this.hesitance, this.eagerness);
            if (this.eagerness == this.hesitance)
                func();
        });
    };
    this.multiSet = function multiSetMediate(...points) {
        this.hesitance += points.length;
        points.forEach( e => {
            e( () => {
                this.eagerness++;
                if (this.eagerness == this.hesitance) {
                    func();
                }
            });
        });
    };
};

var gotoContent = [2,2];
function issueCommand(cmd, out) {
    let xhr = new XMLHttpRequest();
    xhr.open("GET", urlLoc + "cmd");
    xhr.setRequestHeader("content-type", "text/plain");
    xhr.setRequestHeader("sl-cmd", cmd);
    if (cmd.localeCompare("goto") == 0) {
        xhr.setRequestHeader('slide',gotoContent[0]);
        xhr.setRequestHeader('item',gotoContent[1]);
    }
    if (out) out.log("Issuing command \"" + cmd + "\" to " + urlLoc + "cmd");
    xhr.send();
};

var streamSec = document.createElement("section");
streamSec.innerHTML = "<h3>Server Sent Events tests</h3>";
var skipSSEtests = false;
var conOut = getNewOutGroup();
var streamTest = function streamTest() {
    document.body.appendChild(streamSec);
    streamSec.innerHTML += "<h4>EventSource connection</h4>";
    streamSec.appendChild(conOut);
    if (skipSSEtests) {
        conOut.log("Skipped");
        conOut.next();
    } else if (typeof EventSource == "undefined") {
        conOut.log("No browser support for EventSource.");
        conOut.setStatus("warning");
        skipSSEtests = true;
        conOut.next();
    } else {
        var timeout = 10000;
        var esTime = setTimeout(function esTime() {
            conOut.log("Connection timeout after " + timeout + "ms");
             conOut.setStatus("error");
             skipSSEtests = true;
            conOut.next();
            es.close();
        }, timeout);
        conOut.log("Connecting to " + urlLoc + "stream");
        conOut.setStatus("loading");
        let es = new EventSource( urlLoc + "stream" );
        es.addEventListener("connections",  e => { 
            conOut.log("Recieved: (" + e.lastEventId + ") "
                       + e.type + ": " + e.data);
            es.addEventListener("next", e => {
                conOut.log("Recieved: (" + e.lastEventId + ") "
                           + e.type + ": " + e.data);
                conOut.setStatus("loaded");
                clearTimeout(esTime);
                es.close();
                conOut.next();
            }, false);

            issueCommand("next", conOut);
        }, false);
    }
};
(new Mediate(streamTest)).multiSet(srtOut.addNext, assOut.addNext);

var infoList = ["connections"];
var cmdList = ["prev", "next", "goto", "black", "reload", "nej"];
var postCmdList = ["d"];
function addAllCmdObservers(es, out) {
    infoList.concat(cmdList).concat(postCmdList).forEach( e => {
        es.addEventListener(e, f => {
            out.log("Recieved: (" + f.lastEventId + ") "
                    + f.type + ": " + f.data);
        });
    });
};
var sseAllOut = getNewOutGroup();
conOut.addNext(function sseAllTest() {
    streamSec.innerHTML += "<h4>Multiple connections, all commands</h4>";
    streamSec.appendChild(sseAllOut);
    sseAllOut.setTitle("Issuer");
    if (skipSSEtests) {
        sseAllOut.log("Skipped");
        sseAllOut.next();
        return;
    }

    sseAllOut.log("Setting up listeners");
    sseAllOut.setStatus("loading");
    var numListeners = 5;
    var readyListeners = 0;
    var finishedListeners = 0;
    function forward() {
        finishedListeners++;
        if (finishedListeners == numListeners)
            sseAllOut.next();
    };
    // var forward = function forward() {
    //     if (finishedListeners == numListeners && forward.callback) {
    //         if (typeof forward.callback == "function")
    //             forward.callback();
    //         else if ([].isArray(forward.callback))
    //             for (let e of forward.callback) {e();}
    //     }
    // };
    var postContent = ["Test stanza"];
    var testOuts = [];
    var stdInterval = 5000;
    for (var i = 0; i < numListeners; i++) {
        let anOut = getNewOutGroup();
        let step = 0;
        function waitForNextCmd( e ) {
            if (anOut.cTimeout)
                clearTimeout(anOut.cTimeout);
            if (e.type == "goto") {
                anOut.log("Checking \"goto\" payload");
                if (e.data == gotoContent[0] + "\n" + gotoContent[1])
                    anOut.log("OK");
                else {
                    anOut.setStatus("warning");
                    anOut.log("FAILED! Expected "
                              + gotoContent[0] + "\n" + gotoContent[1]);
                }
            }
            if (postCmdList.includes(e.type)) {
                anOut.log("Checking \"" + e.type + "\" payload");
                if (e.data == postContent[postCmdList.indexOf(e.type)])
                    anOut.log("OK");
                else {
                    anOut.setStatus("warning");
                    anOut.log("FAILED! Expected "
                              + postContent[postCmdList.indexOf(e.type)]);
                }
            }

            step++;
            function waitFor( cmd ) {
                anOut.log("Waiting for command: " + cmd);
                anOut.cTimeout = setTimeout( () => {
                    anOut.setStatus("error");
                    anOut.log("Timeout after " + stdInterval
                              + "ms while waiting for \"" + cmd + "\"" );
                    anOut.listener.close();
                    forward();
                }, stdInterval);
            };
            if (step < cmdList.length) {
                waitFor(cmdList[step]);
                anOut.listener.addEventListener(cmdList[step], waitForNextCmd,
                                                {once: true} );
                if (e.target == testOuts[numListeners - 1].listener) {
                    issueCommand(cmdList[step], sseAllOut);
                }
            } else if (step < cmdList.length + postCmdList.length) {
                waitFor( postCmdList[step - cmdList.length]);
                anOut.listener.addEventListener(
                    postCmdList[step - cmdList.length], waitForNextCmd,
                    {once: true});
                if (e.target == testOuts[numListeners - 1].listener) {
                    var xhr = new XMLHttpRequest();
	            xhr.open("post", urlLoc + "cmd");
	            xhr.setRequestHeader('Content-Type','text/plain');
	            xhr.setRequestHeader('sl-cmd',
                                         postCmdList[step - cmdList.length]);
                    sseAllOut.log("Issuing command \""
                                  + postCmdList[step - cmdList.length]
                                  + "\" with payload \""
                                  + postContent[step - cmdList.length]
                                  + "\"");
	            xhr.send(postContent[step - cmdList.length]);
                }
            } else {
                if (anOut.cTimeout)
                    clearTimeout(anOut.cTimeout);
                anOut.log("Closing");
                if (anOut.getStatus() != "warning") anOut.setStatus("loaded");
                
                anOut.listener.close();
                forward();
            }
        };
        anOut.setTitle("Listener " + (i + 1));
        streamSec.appendChild(anOut);
        anOut.setStatus("loading");
        anOut.log("Connecting to " + urlLoc + "stream");
        anOut.listener = new EventSource( urlLoc + "stream");
        anOut.listener.addEventListener(cmdList[0], waitForNextCmd,
                                        {once: true});
        anOut.listener.addEventListener("connections", () => {
            readyListeners++;
            if (readyListeners == numListeners) {
                readyListeners++; // So this doesn't happen twice.
                //step++;
                for (const e of cmdList) {
                    // issueCommand(e, sseAllOut);
                }
                issueCommand(cmdList[0], sseAllOut);

            }
        }, {once: true});
        addAllCmdObservers(anOut.listener, anOut);
        // anOut.listener.addEventListener(cmdList[cmdList.length - 1], () => {
        // });
        testOuts.push(anOut);
    }

    sseAllOut.addNext(function sseAllNext() {
        sseAllOut.log("All listeners closed");

        console.log(sseAllOut);
        for (const e of testOuts) {
            if (e.getStatus() != "loaded") {
                sseAllOut.setStatus("warning");
                return;
            }
        }
        sseAllOut.setStatus("loaded");
    });

    // setTimeout(() => {
    //     issueCommand("next", sseAllOut);
    // }, 1000);
});

// var sseReOut = getNewOutGroup();
// sseAllOut.addNext(function sseAllTest() {
//     streamSec.appendChild(document.createElement("h4"))
//         .textContent = "Command resend";
//     streamSec.appendChild(sseReOut);
//     if (skipSSEtests) {
//         sseReOut.log("Skipped");
//         return;
//     }

//     // let es = new EventSource(urlLoc + "stream");
//     // addAllCmdObservers(es, sseReOut);
//     // console.log(es);
//     // es.addEventListener("connections", () => {
//     //     es.lastEventÃd = 1;
//     //     sseReOut.log(es.lastEventId + "");
//     //     console.log(es);
//     // }, {once: false});

//     let xhr = new XMLHttpRequest();
//     xhr.open("GET", urlLoc + "stream");
//     xhr.setRequestHeader("last-event-id", 1);
//     xhr.setRequestHeader("accept", "text/event-stream");
//     xhr.addEventListener("load", () => {
//         sseReOut.log(xhr.responseText);
//         sseReOut.log(xhr.status + " " + xhr.statusText);
//     });
//     xhr.send();
// });

        </script>
    </body>
</html>
<!-- sse-server test script -->
