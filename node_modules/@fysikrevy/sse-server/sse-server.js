#!/usr/bin/env node
// # Global Setup --------------------------------------------------------------

// Required packages
var http = require("http")
,   args = require("minimist")(process.argv.slice(2))
,   path = require("path")
,   fs = require("fs")
,   srt2vtt = require("srt2vtt")
,   ass2vtt = require("ass-to-vtt")
;

// Global variables
var connections = []
,   lastMessageId = 0
,   history = []
;

var contentTypesByExtension = {
   '.html': "text/html"
  ,'.htm':  "text/html"
  ,'.css':  "text/css"
  ,'.js':   "text/javascript"
  ,'.vtt':  "text/vtt"
  ,'.svg':  "image/svg+xml"
  ,'.jpeg': "image/jpeg"
  ,'.jpg':  "image/jpeg"
  ,'.png':  "image/png"
  ,'.gif':  "image/gif"
  ,'.wav':  "audio/x-wav"
  ,'.mp3':  "audio/mp3"
  ,'.mp4':  "video/mp4"
  ,'.m4v':  "video/mp4"
};

// Accept alternate port number (as first (numeric) argument,
// or "--port=" argument).
var port = 80;                  // Default port
if (args.port) {
  port = parseInt(args.port);
} else {
  for (const a of args._) {
    if (!isNaN(parseInt(a))) {
      port = parseInt(a);
      break;
    }
  }
}


// # HTTP server logic ---------------------------------------------------------

http.createServer( function (req, res) {
  var index = "./stream"
  ,   fileName
  ,   interval
  ;

  if (req.url === "/")
    fileName = index;
  else if ([".remote", ".left", ".right", ".mid"
           ].includes(path.extname(req.url)))
    fileName = "." + path.dirname(req.url) + "/"
      + path.basename(req.url, path.extname(req.url)) + ".html";
  else {
    fileName = "." + decodeURI(req.url);
  }

  if (fileName === "./stream")
    acceptSubscriber( req, res );
  else if (fileName === "./cmd")
    interpretCommand(req, res);
  else
    serveFile(req, res, fileName);
    
}).listen( port, "::");
console.log("Server listening at 0.0.0.0:" + port);

// ## Helper function(s)
function handleFileError( err, res, checkNoEnt ) {
  // Check file existence by default.
  if (checkNoEnt === undefined)
    checkNoEnt = true;
  if (checkNoEnt && err.code === 'ENOENT') { // (Error, NO ENTity)
    res.writeHead(404);
    res.end();
    console.log("NOT FOUND: " + err.path);
  } else {
    res.writeHead(500, {"Content-Type": "text/plain"});
    res.write(err + '\n');
    res.end();
  }
};


// # Serve request handlers ----------------------------------------------------
async function acceptSubscriber( req, res) {
  if ( req.headers.accept === "text/event-stream"
       || req.headers.accept === "*/*" // Needed for a hack elsewhere...
     ) {
    res.writeHead( 200, {
      'content-type': "text/event-stream"
      ,'cache-control': "no-cache"
      ,'connection': "keep-alive"
      ,'Access-Control-Allow-Origin': "*"
    });

    // Support the polyfill
    if (req.headers['x-requested-with'] == 'XMLHttpRequest') 
      res.xhr = null;

    if (req.headers['last-event-id']) {
        var id = parseInt(req.headers['last-event-id']);
        console.log("Request last event id: " + id);
      for (const histItem of history) {
        if (histItem.id > id) {
          sendSSE(res, histItem.id, histItem.event, histItem.message);
        }
      }
    } else {
      // resets the ID
      res.write('id\n\n');
    }

    connections.push(res);
    broadcast('connections', connections.length);

    req.on('close', function () {
      removeConnection(res);
    });
  } 
};  

async function interpretCommand( req, res) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "sl-cmd, slide, item");
  function closeCmd(req) {
      res.write(JSON.stringify(lastMessageId));
      res.end();
  };    
  var closeForMe = true;
  
  switch (req.headers['sl-cmd']) {
  case 'next':
    broadcast('next','');
    break;
  case 'prev':
    broadcast('prev','');
    break;
  case 'goto':
    var slide = req.headers['slide'];
    var item = req.headers['item'];
    broadcast('goto',slide+'\n'+item);
    break;
  case 'black':
    broadcast('black','');
    break;
  case 'reload':
    broadcast('reload','');
    break;
  case 'nej':
    broadcast('nej','');
    break;
  case 'd':
    var stanza = '';
    closeForMe = false;
    req.on('end', () => {
      broadcast('d', stanza);
      closeCmd(req);
    });
    req.on('data', (chunk) => {stanza += chunk;});
    break;
  }

  if (closeForMe) {
    closeCmd(req);
  }
  console.log(req.headers['sl-cmd']);
};

async function serveFile( req, res, fileName) {
  res.setHeader('Access-Control-Allow-Origin', "*");
  res.setHeader('Access-Control-Allow-Headers', "*");
  fs.stat(fileName, (err, stat) => {
    if (err) {
      if (path.extname(fileName) === ".vtt")
          tryOtherSubFormats( req, res, fileName );
	else if (! path.dirname( fileName ).split( "/" ).includes( "node_modules" ) ){
	    return serveFile( req, res, "./node_modules/@fysikrevy/av-main/" + fileName.substring( 2 ) );
	}
      else
        handleFileError(err, res);
    } else {

      var contentType = contentTypesByExtension[path.extname(fileName)]
      ,   total = stat.size
      ,   headers = {}
      ;

      // Caching headers
      var cacheAggressive = [ './fonts'
                            , "./node_modules/@fysikrevy/woff"
                            ];
      if ( cacheAggressive.some( e => fileName.startsWith(e) ) ) {
        headers['Cache-Control'] = "public, max-age=31536000";
      }
      
      if (req.headers['range']) {
        var range = req.headers.range
	,   parts = range.replace(/bytes=/, "").split("-")
	,   partialstart = parts[0]
	,   partialend = parts[1]
	,   start = parseInt(partialstart, 10)
	,   end = partialend ? parseInt(partialend, 10) : total-1
	,   chunksize = (end-start)+1
        ;
	console.log(fileName + ': RANGE: ' + start + ' - ' + end
                    + ' = ' + chunksize + '  TO: ' + req.socket.remoteAddress);
	
	var file = fs.createReadStream(fileName, {start: start, end: end});
        Object.assign(headers, { 'Content-Range': 'bytes ' + start + '-' + end
                                                  + '/' + total
                               , 'Accept-Ranges': 'bytes'
                               , 'Content-Length': chunksize
                               });
        if (contentType) headers['Content-Type'] = contentType;
	res.writeHead(206, headers);
	file.pipe(res).on('end', res.end)
                      .on('error', (err) => handleFileError(err, res));
      } else {
	console.log(fileName + ': (' + total + ')  TO: '
                    + req.socket.remoteAddress);
        headers['Content-Length'] = total;
        if (contentType) headers['Content-Type'] = contentType;
	res.writeHead(200, headers);
	fs.createReadStream(fileName).pipe(res)
          .on('end', res.end )
          .on('error', (err) => handleFileError(err, res));
      }

    }
  });
};

function tryOtherSubFormats( req, res, fileName) {
  fs.readFile
  (path.dirname(fileName) + path.sep
   + path.basename(fileName, ".vtt") + ".srt",
   function(err, srtFile) {
     if (!err) {                // Found an .srt file
       srt2vtt(srtFile, function(s2verr, vttData) {
         if (!s2verr) {
           res.writeHead(200, { 'Content-Type':
                                  contentTypesByExtension['.vtt']
                                   + "; charset=utf-8" });
           res.write(vttData, "utf8");
           res.end();
           console.log(fileName + " (converted from .srt)");

         } else                 // .srt file didn't work
           handleFileError(s2verr, res);
       });
     } else if (err.code === "ENOENT") { // No .srt file
         var assFile = fs.createReadStream(
           path.dirname(fileName) + path.sep
             + path.basename(fileName, ".vtt") + ".ass")
             .on("error", (a2verr) => {
               // res.removeHeader("Content-Type");
               a2verr.path = a2verr.path.replace(".ass", ".vtt");
               handleFileError(a2verr, res);
             })
             .on("end", () => {
               console.log(fileName + " (converted from .ass)  TO: "
                           + req.socket.remoteAddress);
               res.end();
             })
             .on("open", () => {
               res.statusCode = 200;
               res.setHeader("Content-Type", contentTypesByExtension['.vtt']
                             + "; charset=utf-8");
               assFile.pipe(ass2vtt()).pipe(res);
             });
     } else
       handleFileError(err, res);
   });
};
           

// # SSE functions -------------------------------------------------------------
function removeConnection(res) {
  var i = connections.indexOf(res);
  if (i !== -1) {
    connections.splice(i, 1);
  }
  broadcast('connections', connections.length);
  console.log('removed connection');
}

function broadcast(event, message) {
  if (!isNaN(message))  message = JSON.stringify(message);
  ++lastMessageId;
  history.push({
    id: lastMessageId,
    event: event,
    message: message
  });

  console.log('broadcast to %d connections', connections.length);

  connections.forEach(function (res) {
    sendSSE(res, lastMessageId, event, message);
  });
}

function sendSSE(res, id, event, message) {
  var data = '';
  if (event) {
    data += 'event: ' + event + '\n';
  }

  // blank id resets the id counter
  if (id) {
    data += 'id: ' + id + '\n';
  } else {
    data += 'id\n';
  }

  if (message) {
    data += 'data: ' + message.split('\n').join('\ndata:') + '\n';
  }
  data += '\n'; // final part of message

  res.write(data);

  if (res.hasOwnProperty('xhr')) {
    clearTimeout(res.xhr);
    res.xhr = setTimeout(function () {
      res.end();
      removeConnection(res);
    }, 250);
  }
  console.log(message);
}
