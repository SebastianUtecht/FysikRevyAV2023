/* Original Slide Template from http://code.google.com/p/io-2011-slides/ */

// ## Global setup --------------------------------------------------------------

// ### Browser prefixes                                                      ----
window.URL = (window.URL) ? window.URL : (window.webkitURL)
                                           ? window.webkitURL : null;

window.BlobBuilder =   window.BlobBuilder
                    || window.WebKitBlobBuilder
                    || window.MozBlobBuilder;

window.requestFileSystem =   window.requestFileSystem
                          || window.webkitRequestFileSystem;

window.requestAnimationFrame =   window.requestAnimationFrame
                              || window.webkitRequestAnimationFrame
                              || window.mozRequestAnimationFrame
                              || window.msRequestAnimationFrame;

if (!Element.prototype.matches) {
  Element.prototype.matches = 
    Element.prototype.matchesSelector || 
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector || 
    Element.prototype.oMatchesSelector || 
    Element.prototype.webkitMatchesSelector ||
    function(s) {
      var matches = (this.document || this.ownerDocument).querySelectorAll(s),
          i = matches.length;
      while (--i >= 0 && matches.item(i) !== this) {}
      return i > -1;            
    };
}

// ### Global constants                                                      ----
if (typeof PERMANENT_URL_PREFIX == "undefined") {
  PERMANENT_URL_PREFIX = '';
}

const SLIDE_CLASSES = ['far-past', 'past', 'current', 'next', 'far-next'];
const PM_TOUCH_SENSITIVITY = 15;

// ### Global variables                                                      ----
var curSlide;
var isRemote = false;
var overSide = false;
var specialSlideClasses = [];

// ## Initialization ------------------------------------------------------------

function initialize() {
  // Called at the end of this file.
  
  setBehaviourFromURL();
  document.addEventListener('DOMContentLoaded', handleDomLoaded,
                            {useCapture: false, once: true });
};

var slideEls;
function handleDomLoaded() {
  slideEls = [];
  var slideElNodeList = document.querySelectorAll('section.slides > article');
  for ( var i = 0; i < slideElNodeList.length; i++) {
    slideEls.push(slideElNodeList[i]);
  }

  for (var i = 0, slide; slide = slideEls[i]; ++i) {
    slide.dataset.slideNum = i;
    slide.dataset.totalSlides = slideEls.length - 1;
  }

  addAncilliaryScripts().then( () => {
    addGeneralStyle();
    addEventListeners();
    
    sliceForOverSide();
    makeBuildLists();
    if (isRemote)
      makeWindows();
    
    updateSlides();
    setupFrames();
    focusSmallSlide();
    
    document.body.classList.add('loaded');
  });
};

function addAncilliaryScripts() {

  let p = import( "/node_modules/jquery/dist/jquery.min.js" );

  // For downloading internally generated files.
  // Eg. subtitle transcripts.
  var fsScript = document.createElement('script');
  fsScript.type = 'text/javascript';
  fsScript.src = PERMANENT_URL_PREFIX
                + 'node_modules/file-saver/FileSaver.min.js';
  document.head.appendChild(fsScript);

  return p;
};

function addGeneralStyle() {
  var el = document.createElement('link');
  el.rel = 'stylesheet';
  el.type = 'text/css';
  el.href = PERMANENT_URL_PREFIX + 'av.css';
  document.head.appendChild(el);

  if (isRemote) {
    el = document.createElement('link');
    el.rel = 'stylesheet';
    el.type = 'text/css';
    el.href = PERMANENT_URL_PREFIX + 'av-remote.css';
    document.head.appendChild(el);

    checkAndMobilize();
    bigSlideScale();
    window.addEventListener('resize', resizeThrottler, false);	    
  } else {
    el = document.createElement('meta');
    el.name = 'viewport';
    el.content = 'width=1100,height=750';
    document.querySelector('head').appendChild(el);
    
    el = document.createElement('meta');
    el.name = 'apple-mobile-web-app-capable';
    el.content = 'yes';
    document.querySelector('head').appendChild(el);
  }
};

var ignPrev = 0,
    ignNext = 0,
    ignGoto = 0,
    ignBlack = 0,
    ignReload = 0,
    ignD = 0,
    ignNej = 0;

function sliceForOverSide() {
  let overDiscriminator = overSide
      ? `:not( [for='${overSide}']):not( [for='span'] )`
      : '[for]:not( [for="main"] )';
  slideEls = slideEls.map( slide => {
    let otherSiders = $( slide ).find( overDiscriminator );
    console.log("otherSiders", otherSiders );
    while ( otherSiders.length ){
      for ( let other of otherSiders ){
        other = $( other );
        if ( other.find( otherSiders ).length )
          continue;

        let firstItem = other.children( '*:first-child' );
        while ( other.children().length ){
          let item = other.children( '*:first-child' );
          item = item.add( item.nextUntil(
            other.attr( 'for' )
              ? ( item.attr( 'for' ) == other.attr( 'for' )
                  ? `*:not( [for="${other.attr( 'for' )}"] )`
                  : `*[for="${other.attr( 'for' )}"]`
                )
              : ( item.attr( 'for' ) ? "*:not( [for] )" : "*[for]" )
          ));
          console.log( "item", item );
          if ( item.attr( 'for' ) == other.attr( 'for' ) )
            item = $( other[0].cloneNode() ).append( item );
          else if ( other.is( '.build > *:not( .build )' ) )
            item.addClass( "no-build" );
          else if ( other.is( '*:not( .build ) > .build' ) )
            item.addClass( 'build-me' );
          item.insertBefore( other );
        }
        // if (! other.is( '.auto' ) )
        //   firstItem.removeClass( 'auto' );
        // if ( other.attr( 'dur' ) !== void(0) )
        //   firstItem.attr( 'dur', other.attr( 'dur' ) );
        otherSiders = otherSiders.not( other );
        if ( firstItem.length )
          other.remove();
        break;
      }
    }

    if (! slide.matches( overDiscriminator ) )
      return slide;
    
    while( true ){
      let otherSider = $( slide ).find( "*" ).not( overDiscriminator ).first()
      if ( otherSider.length == 0 ) return slide;
      if ( otherSider.is( "section.slides > *" ) ) return otherSider[0];
      // if ( otherSider.parent().length == 0 ) return; // uh-oh...

      otherSider.parent( ":not( .build-me, .no-build )" ).addClass(
        otherSider.is( ".build > * > :not( .build )" )
          ? "build-me"
          : ( otherSider.is( ":not( .build ) > * > .build" )
              ? "no-build"
              : ""
            )
      );
      if ( otherSider.is( ".build > .build" ) ){
        otherSider.prepend(
          $( "<div>" ).css( "display", "none" )
            .attr( "for", otherSider.attr( "for" ) )
        );
      }
      
      // otherSider.parent().addClass(
      //   otherSider.parent().is( ":not( .build ) > * " ) ? 
      // otherSider.add( otherSider.nextAll() )
      //   .filter( ":not( .build-me, .no-build )" )
      //   .addClass( otherSider.parent().is( ":not( .build ) > .build" )
      //              ? "build-me"
      //              : ( otherSider.parent().is( ".build > :not( .build )" )
      //                  ? "no-build"
      //                  : ""
      //                )
      //            );
      if ( otherSider.next().length ){
        otherSider.append(
          $( otherSider.parent()[0].cloneNode( false ) )
            .append( otherSider.nextAll() )
        );
      }
      otherSider.parent().before( otherSider );
      otherSider.next().prependTo( otherSider );
      // otherSider.parent().after( otherSider );

      if ( otherSider.is( "section.slides > *" ) ) return otherSider[0];
    }
  });
};

function slideBuildList( slide ){

  switch ( typeof slide ){
  case 'undefined':
    slide = curSlide;
  case 'number':
    slide = getSlideEl( slide );
    break;
  default:
  }

  return slide.querySelectorAll( '.build-me:not( .no-build ), .build > :not( br ):not( .no-build )' );
}

function makeBuildLists() {

  // Mark elements that can be built.
  for (var i = curSlide, slide; slide = slideEls[i]; i++) {
    var items = slideBuildList( slide );
    for (var j = 0, item; item = items[j]; j++) {
      // if (!item.classList.contains('mimic'))
        item.classList.add('to-build');
    }
  }

  if (isRemote) {
    // Pull media elements out of the remote page.

    var audio = document.getElementsByTagName('audio');
    var video = document.getElementsByTagName('video');
    var media = Array.prototype.slice.call(audio)
                     .concat(Array.prototype.slice.call(video));

    for (var i = 0; i < media.length; i++) {
      var span = document.createElement('div');

      for (var j = 0, attrs = media[i].attributes, l = attrs.length;
           j < l;
           j++
          ) {
        span.setAttributeNode( media[i].getAttributeNode( attrs[j].name)
                                       .cloneNode(true) );
      }
      
      if (media[i].tagName == 'VIDEO') {
        span.classList.add('video');
        span.textContent = "\uD83C\uDF9E ";
      } else {
        span.classList.add('audio');
        span.textContent = "\u266B ";
      }
      if (media[i].classList.contains('auto')) span.classList.add('auto');
      span.textContent = span.textContent
	+ media[i].querySelector('source').getAttribute('src').split('/')[1];
      $(span).append( media[i].children );
      media[i].parentNode.replaceChild(span, media[i]);
    }
  }
};


// ## URL fragment read/edit ----------------------------------------------------

function setBehaviourFromURL() {
  // Pages recieve special roles by their extension: .left, .right and .mid
  // are overslides and .remote is a control panel.
  // The fragment (following a '#' at the end of the URL) holds the current
  // slide number.
  
  var slideNo = parseInt(location.hash.substr(1));
  var pathsplit = location.pathname.split(".");
  var extension = pathsplit[pathsplit.length - 1];

  isRemote = (extension.search("remote") != -1) ? true : false;
  if (['mid', 'left', 'right'].includes(extension)) {
    overSide = extension;
    document.addEventListener('DOMContentLoaded',
                              () => {
                                document.body.classList.add(extension);
                              },
                              {once: true});
  }

  if (slideNo) {
    curSlide = slideNo ;
    // TODO: When to *actually* reload...?
    if (isRemote) reloadControlled();
  } else {
    curSlide = 0;
  }

};

function updateHash() {
  location.replace('#' + (curSlide ));
};


// ## Event listeners -----------------------------------------------------------

function addEventListeners() {
  document.addEventListener('keydown', handleBodyKeyDown, false);
  
  // SSE command listeners
  if (typeof EventSource !== "undefined") {
    // console.log("opening event source");
    var rem = new EventSource(PERMANENT_URL_PREFIX + "stream");
    rem.addEventListener('prev', function() {
      if (!ignPrev) {
	prevSlide(true);
      } else {
	ignPrev--;
      }
    }, false);
    rem.addEventListener('next', function() {
      if (!ignNext) {
	killRepeat();
	nextSlide(true);
      } else {
	ignNext--;
      }
    }, false);
    rem.addEventListener('goto', function(e) {
      if (!ignGoto) {
	var data = e.data.split('\n');
	gotoSlide(parseInt(data[0]),parseInt(data[1]),true);
      } else {
	ignGoto--;
      }
    }, false);
    rem.addEventListener('black', function() {
      if (!ignBlack) {
	blackout(true);
      } else {
	ignBlack--;
      }
    }, false);
    rem.addEventListener('reload', function() {
      // console.log("reload");
      if (!ignReload) {
	reloadSelf();
      } else {
	ignReload--;
      }
    }, false);
    rem.addEventListener('d', (e) => {
      // console.log('Command d' + e.data);
      if (!ignD) {
	inject(e.data);	// inject doesn't trigger a 'cmd'.
      } else {
	ignD--;
      }
    }, false);
    rem.addEventListener('n', (e) => {
      if (!ignNej) {
        setNEJ(true);
      } else {
        ignNej--;
      }
    }, false);

    window.onbeforeunload = function () {
      rem.close();
      // console.log("close connection");
    };
  }

  // Navigation by slide list.
  if (isRemote) {
    for (var i = 0; i < slideEls.length; i++) {
      slideEls[i].addEventListener('click', function() {
	gotoSlide(this.getAttribute('data-slide-num'),0);
      }, false);
    }
  }
};

function handleBodyKeyDown(event) {
  switch (event.keyCode) {
  case 39: // right arrow
  case 13: // Enter
  case 32: // space
  case 34: // PgDn
  case 40: // down arrow
    killRepeat();
    nextSlide(false);
    event.preventDefault();
    break;

  case 37: // left arrow
  case 8: // Backspace
  case 33: // PgUp
  case 38: // up arrow
    prevSlide(false);
    event.preventDefault();
    break;

  case 68:                      // D
    event.preventDefault();
    makeInject();
    break;

  case 75:                      // k
    blackout(false);
    break;

  case 76:			// l
    if (logLines.playButton) logLines.playButton();
    else logLines();
    break;

  case 71: 			// g
    if (logLines.getAssFile) logLines.getAssFile();
    break;

  case 78:                      // n
    event.preventDefault();
    setNEJ();
    break;

  }
};

function itemListeners(list) {
  // Eventlistener to be attached to each list element in the builds list on the
  // control page.
  
  var toListen = list.querySelectorAll('li');
  for (var i = 0; i < toListen.length; i++) {
    toListen[i].addEventListener('click', function() {
      gotoSlide(curSlide, this.getAttribute('data-item-number'));
    }, false);
  }
};


// ## Navigation ----------------------------------------------------------------

function prevSlide(silent) {
  // Will not emit a server command if 'silent' is true.
  
  var targetSlide = (isRemote)
      ? document.getElementById('bigSlide')
      : getSlideEl(curSlide);
    if (targetSlide) targetSlide.dispatchEvent(moveItemEvent);
    

  if (curSlide > 0) {
    let lastBuild, prevBuild = [].slice.call(
        getSlideEl(curSlide).querySelectorAll('.last-build'), -1
      )[0];
    do { 
      lastBuild = prevBuild;
      if (lastBuild) {
        prevBuild = getPrevBuild(lastBuild);
        lastBuild.classList.remove('last-build');
        lastBuild.classList.add('to-build');
	      if (prevBuild) {
	        prevBuild.classList.add('last-build');
	        lastBuildParents( prevBuild );
	      }
      } else {
        curSlide--;
        break;
      }
    } while ( lastBuild.matches( ".auto" ) )

    updateSlides();
  }

  if (targetSlide) targetSlide.dispatchEvent(movedItemEvent);
  
  // Dispatch command
  if (silent !== true) {
    var xhr = new XMLHttpRequest();
    xhr.open("get",PERMANENT_URL_PREFIX + "cmd",true);
    xhr.setRequestHeader('Content-Type','text/plain');
    xhr.setRequestHeader('sl-cmd','prev');
    xhr.send();
    ignPrev++;
  }
};

function nextSlide(silent) {
  // Will not emit a server command if 'silent' is true.
  
  var targetSlide = (isRemote)
      ? document.getElementById('bigSlide')
      : getSlideEl(curSlide);
  if (targetSlide) {
    targetSlide.dispatchEvent(moveItemEvent);
  }
 
  if (silent !== true) {
    var xhr = new XMLHttpRequest();
    xhr.open("get",PERMANENT_URL_PREFIX + "cmd",true);
    xhr.setRequestHeader('Content-Type','text/plain');
    xhr.setRequestHeader('sl-cmd','next');
    xhr.send();
    ignNext++;
  }

  if (curSlide >= 0) {
    if (buildNextItem()) {
      if (targetSlide) targetSlide.dispatchEvent(movedItemEvent);
      return;
    }
  }

  if (curSlide - 1 < slideEls.length ) {
    curSlide++;
    updateSlides();
  }
  if (targetSlide) targetSlide.dispatchEvent(movedItemEvent);
};

function gotoSlide(slide, sub, silent) {
  // Will not emit a server command if 'silent' is true.
  
  var targetSlide = (isRemote)
      ? document.getElementById('bigSlide')
      : getSlideEl(curSlide);
  if (targetSlide) targetSlide.dispatchEvent(moveItemEvent);

  curSlide =+ slide;
  sub--;
  var curBuilds = slideBuildList( curSlide );
  
  for (var i = +curSlide + 1; i < slideEls.length; i++) {
    var tBuild = Array.prototype.slice
        .call( slideBuildList( i ) );
    curBuilds = Array.prototype.slice.call(curBuilds).concat(tBuild);
  }
  for (var i = +sub + 1; i < curBuilds.length; i++) {
    // if (!curBuilds[i].classList.contains('mimic')) {
      curBuilds[i].classList.add('to-build');
      curBuilds[i].classList.remove('last-build');
    // }
  }
  for (var i = 0; i <= sub; i++) {
    curBuilds[i].classList.remove('to-build', 'last-build');
  }
  buildAction( (sub >= 0) ? curBuilds[sub] : false );
  console.log('gotoSlide: going to ' + slide + ' ' + sub);
  updateSlides( true );
  // removeBlackout();

  if (curBuilds[sub] && curBuilds[sub].classList.contains('repeat')
      && !curBuilds[sub].classList.contains('mimic') ) {
    var duration = (curBuilds[sub].hasAttribute('dur'))
	? curBuilds[sub].getAttribute('dur')
	: 150;
    curBuilds[sub].classList.add('to-build');
    console.log("rebuild");
    setTimeout(buildNextItem,duration);
    return true;
  }

  var nextBuild = document.querySelector(
    ((isRemote) ? '#bigSlide' : '.current')
      + ' .to-build');
  if (nextBuild && nextBuild.classList.contains('auto')) {
    console.log('goto found auto');
    if (curBuilds[sub].hasAttribute('dur')) {
      setTimeout(buildNextItem, curBuilds[sub].getAttribute('dur'));
      console.log(curBuilds[sub].getAttribute('dur'));
    } else {
      console.log("nodur");
      setTimeout(buildNextItem,150);
    }
  }

  if (silent !== true) {
    var xhr = new XMLHttpRequest();
    xhr.open("get",PERMANENT_URL_PREFIX + "cmd",true);
    xhr.setRequestHeader('Content-Type','text/plain');
    xhr.setRequestHeader('sl-cmd','goto');
    xhr.setRequestHeader('slide',slide.toString());
    xhr.setRequestHeader('item',(sub+1).toString());
    xhr.send();
    ignGoto++;
    console.log("goto: " +slide+','+sub);
  }
  
  if (targetSlide) targetSlide.dispatchEvent(movedItemEvent);
  return false;
};

function buildNextItem() {
  var toBuild  = slideEls[curSlide].querySelectorAll('.to-build');
  if (overSide && toBuild.length) {
    // We're relying on the mimicking element being the last one in its
    // container.
    toBuild[0].classList.remove("to-build");
    var newMimic = getLastRevealedMimicIn(toBuild[0]);
    console.log("newMimic", newMimic);
    if (newMimic) {
      newMimic = newMimic.cloneNode(true);
      newMimic.classList.add("mimicking");
      newMimic.classList.remove("mimic");
      clearMimicsFromNode(slideEls[curSlide]);
      slideEls[curSlide].append(newMimic);
      if (newMimic.classList.contains("span"))
        slideEls[curSlide].classList.add("span");
      toBuild = [newMimic];
    } else {
      var mimicBuild = slideEls[curSlide]
          .querySelectorAll('.mimicking .to-build');
      if (mimicBuild.length) toBuild = mimicBuild;
    }
  }
  
  if (!buildAction( ((toBuild.length) ? toBuild[0] : false),
                    getSlideEl(curSlide) )
     )
    return false;
  
  if (isRemote) buildNextBigItem();
  //updateSlides();
  controlPlayback();

  // TODO: Check that the repeat mechanism works as intended. I have concerns...
  if (toBuild[0].classList.contains('repeat')
      && !toBuild[0].classList.contains('mimic')
     ) {
    
    var duration = (toBuild[0].hasAttribute('dur'))
	? toBuild[0].getAttribute('dur')
	: 150;
    toBuild[0].classList.add('to-build');
    console.log("rebuild");
    setTimeout(buildNextItem,duration);
    return true;
  }

  // Remember, when working with 'auto', the 'dur' attribute controls how long
  // the current element should stick around before being replaced by a following
  // auto, *not* now long an elemnt with 'auto' should wait before replacing the
  // preceeding element.
  if (toBuild[1] && toBuild[1].classList.contains('auto')) {
    console.log( toBuild[1] );
    if (toBuild[0].hasAttribute('dur')) {
      setTimeout(buildNextItem, toBuild[0].getAttribute('dur'));
      // console.log(toBuild[0].getAttribute('dur'));
    } else {
      // console.log("nodur");
      setTimeout(buildNextItem,150);
    }
  }

  return true;
};

function updateSlides( seekMedia = false ) {
  // Set everything to display the current slide and build iten correctly.
  
  // console.log("updateSlides");
  for (var i = 0; i < slideEls.length; i++) {
    switch (i) {
    case curSlide:
      updateSlideClass(i, 'current');
      break;
    default:
      updateSlideClass(i);
      break;
    }
  }

  // If you have an image-heavy deck, set the image src attribute to something
  // fake, and put the real source in the attribute data-src. This bit then
  // undoes that only when those image tags are in the active slide on the main
  // page.
  if (!overSide) {
    var unFake = document.querySelectorAll('.current img');
    for (var n = 0; n < unFake.length; n++) {
      if (unFake[n].dataset.src) {
        unFake[n].src = unFake[n].dataset.src;
      }
    }
  }
  
  // Preload media on the current slide.
  listMediaIn(slideEls[curSlide], ".mimic")
    .forEach( e => e.preload = "auto" );  

  if (isRemote) {
    pickBigSlide();
    focusSmallSlide();
  }

  stopAllPlayback();
  controlPlayback( seekMedia );
  loopAdvarsler();

  // Set up special behaviours for the current build.
  var currentSlides = document.querySelectorAll('.current, #bigSlide');
  if (currentSlides.length > 0)  {
    var timerEls = [];
    for (var i = 0; i < currentSlides.length; i++) {
      // console.log(i);

      // Line up builds with timers
      var tempEls = currentSlides[i].querySelectorAll('.timer');
      for (var j = 0; j < tempEls.length; j++) {
	timerEls.push(tempEls[j]);
      }

      // Mimics do things
      if (overSide) {
        clearMimicsFromNode(currentSlides[i]);
        var mimicNode = getLastRevealedMimicIn(currentSlides[i]);
        if (mimicNode) {
          mimicNode = mimicNode.cloneNode(true);
          mimicNode.classList.remove("mimic");
          mimicNode.classList.add("mimicking");
          currentSlides[i].append(mimicNode);
          if (mimicNode.classList.contains("span"))
            currentSlides[i].classList.add("span");
        }
      }
      
      // TODO: Get mimics to do the right things.
      // function mimicMe(el) {
      //   // What is inserted, and where
      //   var mTarget;
      //   var inserting;
      //   if (el.matches('.slides > article article')) {
      //     mTarget = document.querySelector('.current');
      //     var clCur = mTarget.classList.contains('current');
      //     var clBu = mTarget.classList.contains('build');
      //     mTarget.classList = el.classList;
      //     if (clCur) mTarget.classList.add('current');
      //     if (clBu) mTarget.classList.add('build');
      //     mTarget.classList.add('mimicking');
      //     mTarget.classList.remove('mimic');
      //     inserting = [];
      //     for (var j = 0; j < el.children.length ; j++) {
      //       var iTemp = el.children[j].cloneNode(true);
      //       iTemp.classList.add('mimicking');
      //       inserting.push(iTemp);
      //     }
      //   } else {
      //     if (el.dataset.mimicTarget) {
      //       mTarget = document.getElementById(el.dataset.mimicTarget);
      //     }
      //     if (!mTarget || !mTarget.matches('article.mimicking *')) {
      //       mTarget = document.querySelector('.current');
      //     }
      //     inserting = el.cloneNode(true);
      //     inserting.classList.add('mimicking');
      //     if (inserting.classList.contains('span')) {
      //       mTarget.classList.add('span');
      //     } else {
      //       mTarget.classList.remove('span');
      //     }
      //   }

      //   // Clear out previous inserts
      //   // console.log(document.querySelector('.current'));
      //   for (var j = mTarget.children.length - 1; j >= 0; j--) {
      //     if (mTarget.children[j].classList.contains('mimicking')) {
      //       mTarget.removeChild(mTarget.children[j]);
      //     }
      //   }

      //   // Insert new inserts
      //   if (!Array.isArray(inserting)) {
      //     inserting = [inserting];
      //   }
      //   while (inserting.length > 0) {
      //     let thisInsert = inserting.pop();
      //     mTarget.appendChild(thisInsert);
      //     window.setTimeout(() => {
      //       thisInsert.classList.add("go");
      //     }, 150);
      //   }

      //   // Set mimicking
      //   mTarget.classList.add('mimicking');

      //   // Prepare cleanup...?
      // };

      // function mimicObserverFunc(mutations, observer) {
      //   for (var mutation of mutations) {
      //     console.log(mutation);
      //     if (mutation.type == 'attributes'
      //         && mutation.attributeName == 'class'
      //         && !mutation.target.classList.contains('to-build')) {
      //       observer.disconnect();
      //       console.log("Fire!");
      //       var myMimics = mutation.target
      //           .querySelectorAll(':not(.to-build) .mimic');
      //       for (var j = 0; j < myMimics.length; j++) mimicMe(myMimics[j]);
      //       controlPlayback();
      //     }
      //   }
      // };

      // var mimics = currentSlides[i].querySelectorAll('.mimic');
      // for (var j = 0; j < mimics.length; j++) {
      //   if (overSide && (mimics[j].classList.contains('span')
      //                    || mimics[j].classList.contains(overSide))) {
      //     if (mimics[j].matches('.to-build *')) {
      //       console.log("Other");
      //       var buildParent = mimics[j];
      //       while (buildParent.parentNode) {
      //         buildParent = buildParent.parentNode;
      //         if (buildParent.classList.contains('to-build')) {
      //           console.log(buildParent);
      //           var mimicObserver = new MutationObserver(mimicObserverFunc);
      //           mimicObserver.observe(buildParent, {attributes: true});
      //           break;
      //         }
      //       }
      //     } else {
      //       mimicMe(mimics[j]);
      //     }
      //   }
      // }
    }
    
    if (timerEls.length > 0) {
      var tempTime = new Date();
      var zeroTime = new Date(tempTime.getTime() + 20*60000 + 3000);
      for (var i = 0; i < timerEls.length; i++) {
	timerEls[i].innerHTML='T-20:00:00';
      }

      setTimeout(function(){runTimer(timerEls,zeroTime);},3000);
    }
  }

  var mPlays = document.querySelectorAll('.current .mimic video, .current .mimicking video');
  console.log(mPlays);
  for (var j = 0; j < mPlays.length; j++) {
    mPlays[j].preload = "auto";
  }

  triggerLeaveEvent(curSlide - 1);
  triggerEnterEvent(curSlide);

  window.setTimeout(function() {
    // Hide after the slide
    disableSlideFrames(curSlide - 2);
  }, 301);

  enableSlideFrames(curSlide - 1);
  enableSlideFrames(curSlide + 1);
  enableSlideFrames(curSlide + 2);

  updateHash();
};

// ### Helper functions                                                      ----
function killRepeat() {
  var toBuild = document.querySelectorAll('.to-build .last-build .repeat');
  if (toBuild.length) {
    for (var i=0; i<toBuild.length; i++) {
      toBuild[i].classList.remove('repeat');
    }
  }
};

function clearMimicsFromNode(node) {
  node.querySelectorAll(".mimicking").forEach(
    e => e.parentNode.removeChild(e)
  );
  node.classList.remove("span");
};

function getLastRevealedMimicIn(node) {
  var dupeNode = node.cloneNode(true);
  dupeNode.querySelectorAll(".to-build").forEach(
    e => {
      [].forEach.call(
        e.children,
        f => e.removeChild(f)
      );
    });
  var dupedRevealedMimics = dupeNode.querySelectorAll(".mimic");
  if (!dupedRevealedMimics.length && node.classList.contains("mimic"))
    // It was me all along
    return node; 
  var revealedMimics = [].filter.call(
    node.querySelectorAll(".mimic"),
    e => {
      return [].some.call(
        dupedRevealedMimics,
        f => f.isEqualNode(e)
      );
    });
  console.log("revealedMimics", revealedMimics);
  return revealedMimics.pop();
};

function getPrevBuild(lastBuild) {
    return $( slideBuildList() ).filter( ":not( .to-build )" )
	.get(-2);
  // do {
  //   lastBuild = lastBuild.previousSibling;
  // } while (lastBuild && lastBuild.nodeType!=1);
  // return lastBuild;
};

function buildAction(newItem, slide) {
  
  if (slide) {
    var lastBuilds = slide.querySelectorAll('.last-build');
    lastBuilds = removeLastBuildParents(lastBuilds, newItem);
    for (var i = 0; i < lastBuilds.length; i++) {
      // if (parents.indexOf(lastBuilds[i]) == -1) {
      lastBuilds[i].classList.remove('last-build');
      // }
    }
  }

  if ( newItem ) {    
    lastBuildParents(newItem);
    newItem.classList.remove('to-build');
  }

  //logLines();
  
  return newItem;	
};

function lastBuildParents(curBuild) {
  // Add the '.last-build' class to parent chain of element, up to final build
  // element in the chain.

  if (curBuild.matches('.build-me:not( .no-build ), .build > :not(br):not( .no-build)')) {
    curBuild.classList.add('last-build');
  }
    $( curBuild ).parents().filter( '.build-me:not(.no-build), .build > :not(br):not( .no-build)' ).addClass( 'last-build' );
};

function removeLastBuildParents(lastBuilds, curBuild) {
  // Remove '.last-build' from elements in list (possibly nodeList, possibly
  // array, possibly other workable target for Array.prototype.slice() )
  // lastBuilds, unless that element is a parent of element curBuild.
  
  lastBuilds = [].slice.call(lastBuilds,0);
  var parents = [];
  if (curBuild && curBuild.parentElement) {
    parents.push(curBuild.parentElement);
    while (parents[parents.length - 1].parentElement) {
      parents.push(parents[parents.length - 1].parentElement);
    }
  }
  for (var i=0; i<lastBuilds.length; i++) {
    if (parents.indexOf(lastBuilds[i]) != -1) {
      if (lastBuilds.length) {
	lastBuilds.splice(i,1);
	i--;
      } else {
	return [];
      }
    }
  }

  return lastBuilds;
}

function getSlideEl(no) {
  if ((no < 0) || (no >= slideEls.length)) {
    return null;
  } else {
    return slideEls[no];
  }
};

function updateSlideClass(slideNo, className) {
  var el = getSlideEl(slideNo);

  if (!el) {
    return;
  }

  if (className) {
    el.classList.add(className);
  }

  for (var i in SLIDE_CLASSES) {
    if (className != SLIDE_CLASSES[i]) {
      el.classList.remove(SLIDE_CLASSES[i]);
    }
  }
};

// ### loopAdvarsler                                                         ----
// If it ain't broke...

function loopAdvarsler() {
  var advarsler = document.querySelectorAll('.turner.current,.turner#bigSlide');
  if (advarsler.length <= 0) return;
  for (var i = 0; i < advarsler.length; i++) {
    var divs = advarsler[i].querySelectorAll('.turner > div');
    var found = false;
    for (var j = 0; j < divs.length; j++) {
      if (divs[j].classList.contains('on')) {
	found = true;
	//console.log("found");
	if (j == divs.length - 1) {
	  divs[0].classList.add('on');
	} else {
	  divs[j+1].classList.add('on');
	}
	divs[j].classList.remove('on');
	break;
      }
    }
    if (!found) {
      divs[0].classList.add('on');
    }
  }
  var timeout = (advarsler[0].hasAttribute('dur')) ?
      advarsler[0].getAttribute('dur') : 10000;

  setTimeout(function(){loopAdvarsler();},timeout);
}


// ## Manipulation --------------------------------------------------------------

function blackout(silent) {
  document.body.classList.toggle('blackout');
  stopAllPlayback();
  document.addEventListener('moveitem', removeBlackout, false);
  
  if (!silent) {
    console.log('send blackout');
    var xhr = new XMLHttpRequest();
    xhr.open("get",PERMANENT_URL_PREFIX + "cmd",true);
    xhr.setRequestHeader('Content-Type','text/plain');
    xhr.setRequestHeader('sl-cmd','black');
    xhr.send();
    ignBlack++;
  }

  var targetSlide = (isRemote)
      ? document.getElementById('bigSlide')
      : getSlideEl(curSlide);
  if (targetSlide) targetSlide.dispatchEvent(movedItemEvent);
};

function removeBlackout() {
  document.body.classList.remove('blackout');

  var targetSlide = (isRemote)
      ? document.getElementById('bigSlide')
      : getSlideEl(curSlide);
  if (targetSlide) targetSlide.dispatchEvent(movedItemEvent);
};

function reloadControlled() {
  var xhr = new XMLHttpRequest();
  xhr.open("get",PERMANENT_URL_PREFIX + "cmd",true);
  xhr.setRequestHeader('Content-Type','text/plain');
  xhr.setRequestHeader('sl-cmd','reload');
  xhr.send();
  ignReload++;
  console.log("relaod controlled");
};

function reloadSelf() {
  if (ignReload) {
    ignReload--;
  } else if (!isRemote) {
    location.reload(true);
  }
};

function setNEJ(silent) {
  // Mark items that need attention

  if (silent !== true) {
    var xhr = new XMLHttpRequest();
    xhr.open("get",PERMANENT_URL_PREFIX + "cmd",true);
    xhr.setRequestHeader('Content-Type','text/plain');
    xhr.setRequestHeader('sl-cmd','nej');
    xhr.send();
    ignNej++;
  }

  if (isRemote) {
    document.querySelector("#bigSlide .last-build").classList.toggle("nej");
    document.querySelector(".current .last-build").classList.toggle("nej");
    var builtAnn = document.querySelectorAll("#annlist :not(.to-build)");
    builtAnn[builtAnn.length - 1].classList.toggle("nej");
  }
};

// ### Live inject a line                                                    ----
function makeInject(silent) {
  var replacing = (isRemote)
      ? document.getElementById('bigSlide')
      : getSlideEl(curSlide);
  var injecting = document.createElement("article");
  if (isRemote) {
    injecting.id = "bigSlide";
  } else {
    injecting.classList.add('current');
    if (getSlideEl(curSlide)) slideEls[curSlide] = injecting;
  }
  injecting.classList.add('lyr');

  var form = document.createElement("form");
  function formSubmit(event) {
    console.log(event.key, silent);
    if (event.keyCode === undefined || event.keyCode == 13) {
      var inserting = form.elements[0].value;
      if (silent !== true) {
	var xhr = new XMLHttpRequest();
	xhr.open("post",PERMANENT_URL_PREFIX + "cmd",true);
	xhr.setRequestHeader('Content-Type','text/plain');
	xhr.setRequestHeader('sl-cmd','d');
	xhr.send(inserting);
	ignD++;
      }
      inject(inserting);
    }
    
    injecting.parentElement.replaceChild(replacing, injecting);
    if (isRemote) {
      replacing.id = "bigSlide";
    } else {
      replacing.classList.add('current');
      if (getSlideEl(curSlide)) slideEls[curSlide] = replacing;
    }
  };
  
  form.classList.add('last-build');
  form.action = 'cmd';
  form.method = 'post';
  injecting.appendChild(form);
  var field = document.createElement("textarea");
  field.rows = 5;
  field.name = 'stanza';
  form.appendChild(field);
  field.addEventListener('keydown', function(event) {
    event.stopPropagation();
    if (event.key == "Enter" && event.ctrlKey) {
      field.blur();
    } else if (event.key == "Escape") {
      event.preventDefault();
      field.value = "";
      field.blur();
    }
  }, false);
  var tooltip = document.createElement("p");
  tooltip.classList.add("tip");
  tooltip.textContent = "Ctrl + \u23CE to submit";
  form.appendChild(tooltip);
  replacing.parentElement.replaceChild(injecting, replacing);
  field.focus();
  field.addEventListener('blur', formSubmit, false); // Race condition.
};

function inject(stanza) {
  var replacing = (isRemote)
      ? document.getElementById('bigSlide')
      : getSlideEl(curSlide);
  if (replacing) replacing.dispatchEvent(moveItemEvent);
  // moveItemEvents might put a different element in that spot.
  replacing = (isRemote)
    ? document.getElementById('bigSlide')
    : getSlideEl(curSlide);

  if (stanza == "") return;	// Pretend like it's a cancel.
  var injecting = document.createElement("article");
  if (isRemote) {
    injecting.id = "bigSlide";
  } else {
    injecting.classList.add('current');
    if (getSlideEl(curSlide)) slideEls[curSlide] = injecting;
  }
  injecting.classList.add('lyr');
  
  var overSlide = document.createElement('p');
  // I knew this would come back to bite me...
  overSlide.classList.add('last-build'); 
  var inserting = stanza.split('\n');
  overSlide.textContent = inserting.shift();
  while (inserting.length) {
    overSlide.appendChild(document.createElement('br'));
    overSlide.appendChild(document.createTextNode(inserting.shift()));
  }
  injecting.appendChild(overSlide);
  replacing.parentElement.replaceChild(injecting, replacing);

  function unInject() {
    console.log('Uninjecting');
    injecting.parentElement.replaceChild(replacing, injecting);
    if (isRemote) {
      replacing.id = "bigSlide";
    } else {
      replacing.classList.add('current');
      if (getSlideEl(curSlide)) slideEls[curSlide] = replacing;
    }
    document.removeEventListener('moveitem', unInject);
  };
  document.addEventListener('moveitem', unInject, false);

};


// ## Preloading iframes --------------------------------------------------------
// I mean, you use iframes, right?

function disableSlideFrames(no) {
  var el = getSlideEl(no);
  if (!el) {
    return;
  }

  var frames = el.getElementsByTagName('iframe');
  for (var i = 0, frame; frame = frames[i]; i++) {
    disableFrame(frame);
  }
};

function enableSlideFrames(no) {
  var el = getSlideEl(no);
  if (!el) {
    return;
  }

  var frames = el.getElementsByTagName('iframe');
  for (var i = 0, frame; frame = frames[i]; i++) {
    enableFrame(frame);
  }
};

function disableFrame(frame) {
  frame.src = 'about:blank';
};

function enableFrame(frame) {
  var src = frame._src;
  if (src && frame.src != src) {
    frame.src = src;
  }
};

function setupFrames() {
  var frames = document.querySelectorAll('iframe');
  for (var i = 0, frame; frame = frames[i]; i++) {
    frame._src = frame.src;
    disableFrame(frame);
  }

  enableSlideFrames(curSlide - 1);
  enableSlideFrames(curSlide);
  enableSlideFrames(curSlide + 1);
  enableSlideFrames(curSlide + 2);
};


// ## Slide events --------------------------------------------------------------

function triggerEnterEvent(no) {
  var el = getSlideEl(no);
  if (!el) {
    return;
  }

  var onEnter = el.getAttribute('onslideenter');
  if (onEnter) {
    new Function(onEnter).call(el);
  }

  var evt = document.createEvent('Event');
  evt.initEvent('slideenter', true, true);
  evt.slideNumber = no + 1; // Make it readable

  el.dispatchEvent(evt);
};

function triggerLeaveEvent(no) {
  var el = getSlideEl(no);
  if (!el) {
    return;
  }

  var onLeave = el.getAttribute('onslideleave');
  if (onLeave) {
    new Function(onLeave).call(el);
  }

  var evt = document.createEvent('Event');
  evt.initEvent('slideleave', true, true);
  evt.slideNumber = no + 1; // Make it readable

  el.dispatchEvent(evt);
};

var moveItemEvent = new Event('moveitem', {"bubbles": true});
var movedItemEvent = new Event('moveditem', {"bubbles": true});


// ## Control page (.remote) functionality --------------------------------------

function makeWindows() {
  // Set up the extra bits in the remote view.
  
  var title = document.createElement('div');
  title.classList.add("top");
  var first = document.body.firstChild;
  document.body.insertBefore(title, first);

  document.querySelectorAll('section.slides')[0]
    .addEventListener('click', () => {
      makeMeActive(document.querySelectorAll('section.slides')[0]);
    }, false);

  // Most of the stuff goes in the 'middle' element.
  var middle = document.createElement('div');
  middle.id = "middle";
  middle.classList.add("slides", "active");
  middle.addEventListener('click', () => {makeMeActive(middle);}, true);
  document.body.insertBefore( middle, first );

  // A menu with some commands, for convenience. And possibly touch enablement.
  var menu = document.createElement('div');
  menu.id = "vmenu";
  menu.addButton = (label, id, cfunc) => {
    var nButton = document.createElement('div');
    nButton.textContent = label;
    nButton.id = id;
    nButton.addEventListener('click', cfunc, false);
    menu.appendChild(nButton);
  };

  menu.addButton('\u2329←', 'prev-button', prevSlide);
  menu.addButton('| d', 'd-button', makeInject);
  menu.addButton('\u25A8k', 'black-button', ()=>{blackout(false);});
  menu.addButton('\uD83D\uDCC3l', 'log-button', logLines);
  menu.addButton('→\u232A', 'next-button', nextSlide);

  middle.appendChild(menu);

  // The bigSlide is the main preview.
  var bigSlide = document.createElement('article');
  bigSlide.id = "bigSlide";
  middle.appendChild(bigSlide);

  // The annlist is the list of elements to be built in the current slide.
  var ann = document.createElement('div');
  ann.id = "ann";
  ann.addEventListener('click', () => {makeMeActive(ann);}, false);
  var list = document.createElement('ol');
  list.id = "annlist";
  ann.appendChild(list);
  document.body.insertBefore( ann, first);
};

function pickBigSlide() {
  // Put up a clone of the current slide up as the main preview.
  
  var curBig = document.getElementById('bigSlide');
  var nextBig = getSlideEl(curSlide).cloneNode(true);
  if (curBig) {
    curBig.parentNode.replaceChild(nextBig,curBig);
  } else if (document.getElementById('ann')) {	
    document.getElementById('middle')
      .insertBefore(nextBig,document.getElementById('ann'));
  } else {
    // That's not a good sound...
    document.getElementById('middle').appendChild(nextBig);
  }
  nextBig.id = "bigSlide";
  nextBig.classList.remove("current");

  // Also build the list of elements to build in the current slide
  var list = document.createElement('ol');
  var curBuilds = slideBuildList();
  if (curBuilds.length > 0) {
    for (var i = 0; i < curBuilds.length; i++) {
      if (curBuilds[i].classList.contains('auto')
          // || curBuilds[i].classList.contains('mimic')
         ) continue;
      var nextItem = document.createElement('li');
      if (curBuilds[i].classList.contains('to-build')) {
	nextItem.classList.add('to-build');
      }
      if (curBuilds[i].classList.contains('nej')) {
        nextItem.classList.add('nej');
      }
      nextItem.innerHTML = curBuilds[i].id
        || curBuilds[i].innerHTML
        || curBuilds[i].alt
        || curBuilds[i].tagName;
      var imgs = nextItem.getElementsByTagName('img');
      if (imgs.length > 0) {
      	for (var j = 0; j < imgs.length; j++) {
	  var span = document.createElement('span');
      	  span.innerHTML = '\uD83D\uDDBC '
	    + imgs[j].getAttribute('src')
                     .split('/')[imgs[j].getAttribute('src')
                                        .split('/').length
                                 - 1];
      	  imgs[j].parentNode.replaceChild(span,imgs[j]);
	}
      }
      var brs = nextItem.getElementsByTagName('br');
      for (var j = 0; brs.length && j < brs.length; j++){
	var node = document.createTextNode(' / ');
	brs[j].parentElement.replaceChild(node,brs[j]);
      }
      nextItem.textContent = nextItem.textContent;
      // console.log(nextItem);
      var num = document.createAttribute('data-item-number');
      num.value = i + 1;
      // Caution! Item list numbers start at 1 !
      nextItem.setAttributeNode(num);
      list.appendChild(nextItem);
    }
  }
  itemListeners(list);
  document.getElementById('annlist').parentNode
    .replaceChild(list,document.getElementById('annlist'));
  list.id='annlist';
  
  var listBuilds = list.querySelector('.to-build');
  // var i = 0;
  if (listBuilds)
    document.getElementById('ann').scrollTop = listBuilds.offsetTop -100;
  focusSmallSlide();
};

function buildNextBigItem() {
  focusSmallSlide();

  var toBuild  = document.querySelectorAll('#bigSlide .to-build');
  if (!buildAction( ((toBuild.length) ? toBuild[0] : false),
                    document.getElementById("bigSlide"))
     )
    return;

  // TODO: What is even?
  var listBuildList = document.querySelectorAll('#ann .to-build');
  var ite = 0;
  while (true) {
    if (!listBuildList[ite]) return;
    if (!toBuild[0].classList.contains('auto')) {
      listBuildList[ite].classList.remove('to-build');
    }
    ite++;
    if (listBuildList[ite] && listBuildList[ite].matches('#annlist > *')) {
      break;
    }
  }
  var listBuild = listBuildList[ite].previousSibling;
  document.getElementById('ann').scrollTop = listBuild.offsetTop - 100;
  
}

function focusSmallSlide() {
  // Make sure the current slide is in view in the slides menu
  
  if (isRemote)
    document.querySelectorAll('section.slides')[0].scrollLeft =
       getSlideEl(curSlide).offsetLeft;
};

// ### Responsive design                                                     ----
function makeMeActive(me) {
  // Pick the main element in a compact layout
  
  var notMe = document.getElementsByClassName('active');
  for (var i = 0; i < notMe.length; i++) {
    notMe[i].classList.remove('active');
  }
  me.classList.add('active');
};

function checkAndMobilize(fromResize) {
  // Choose between compact (vertical) and normal layout.
  
  if ((fromResize &&
       document.body.clientWidth/document.body.clientHeight < 11/16)
      ||
      (!fromResize && window.innerWidth/window.innerHeight < 11/16))
  {
    document.body.classList.add("mobile");
  } else {
    document.body.classList.remove("mobile");
  }
};

function resizeThrottler() {
  // Listens for page rescales, and adjusts the layout, at reasonable intervals.

  // There can be only one.
  window.removeEventListener('resize', resizeThrottler);
  
  setTimeout(function() {
    checkAndMobilize(true);
    bigSlideScale();
    window.addEventListener('resize', resizeThrottler, false);
  }, 300);
};

var scaleSheet;
function bigSlideScale() {
  // Scale bigSlide for the current page proportions.
  
  if (!isRemote) return;	// Don't touch any of the actual displays.
  if (scaleSheet === undefined) {
    scaleSheet = document.createElement('style');
    document.head.appendChild(scaleSheet);
  }
  var ruleList = scaleSheet.sheet.cssRules, ruleKillList = [];
  for (var i = 0; ruleList && i < ruleList.length; i++) {
    if (   ruleList[i].type == CSSRule.STYLE_RULE
	   && ruleList[i].selectorText.search('#bigSlide') >= 0) {
      ruleKillList.push(i);
    }
  }
  for (var i = ruleKillList.length - 1; i >= 0; i--) {
    scaleSheet.sheet.deleteRule(i);
  }
  
  var bigSlide = document.getElementById('bigSlide'), cWidth;
  if (bigSlide) 
    cWidth = bigSlide.offsetWidth;
  else
    cWidth = 427;
  var scale = (document.body.clientWidth - 30)
      / cWidth
      * ((document.body.classList.contains('mobile')) ? 1 : 0.4);
  scaleSheet.sheet.insertRule('#bigSlide { '
                              + 'transform: scale(' + scale + ',' + scale + ');'
                              + 'transform-origin: 0% 0%;'
                              + '}',0);
};


// ## Media playback comtrol ----------------------------------------------------

function listMediaIn(node, overDiscriminator) {
  // Skip media elements on overSides that are not in a mimicking element.
  var filterString = // (overSide && overDiscriminator)
      // ? overDiscriminator + " "
      // : 
      "";
  var audio = slideEls[curSlide].querySelectorAll(filterString + 'audio');
  var video = slideEls[curSlide].querySelectorAll(filterString + 'video');
  return Array.prototype.slice.call(audio)
    .concat(Array.prototype.slice.call(video))
    // .filter( e => e.matches(
    //   (overSide && overDiscriminator)
    //     ? overDiscriminator + " *"
    //     : "*"
    // ))
  ;
}  

function controlPlayback( fromStart = false ) {
  // Play the media elements that need to be played, and halt the rest.
  var media = listMediaIn(slideEls[curSlide], ".mimicking");
  console.log("media", media);
  console.log("parents", media.map(e => e.parentNode));

  for (var i = 0; i < media.length; i++) {
    if (!media[i].classList.contains('rununder')
        || !media[i].matches(".mimicking *")
        || media[i].matches(".last-build")
       )
      media[i].pause();
  }
  // console.log(media);
  for (var i = 0; i < media.length; i++) {
    if (media[i].matches('.go *')) console.log("Go"); else {
      console.log("no go");
      console.log(media[i].parentElement);
    }
    if (media[i].classList.contains('last-build')
        || (media[i].classList.contains('parent-link')
	 && media[i].parentNode.classList.contains('last-build'))
        || media[i].matches('.go *')) {
      console.log("fire");
      if ( fromStart ){
         media[i].currentTime = 0;
      }
      media[i].play();
      break;
    }
  }
};

function stopAllPlayback() {
  console.log( "stopall");
  var audio = document.getElementsByTagName('audio');
  var video = document.getElementsByTagName('video');
  var media = Array.prototype.slice.call(audio)
      .concat(Array.prototype.slice.call(video));

  for (var i = 0; i < media.length; i++) {
    media[i].pause();
  }
};


// ## Logging for subtitle file -------------------------------------------------

function logLines(command) {
  var blank;
  
  if (command === false) {
    if (typeof logLines.stop === 'function') return logLines.stop();
  }

  if (command === true) {
    if (typeof logLines.start === 'function') {
      return logLines.start();
    }
  }

  if (typeof blank === 'function') {
    return blank();
  } else {
    var timeline = [{ "ts": new Date(), "line": ""}];

    function logLine(evt) {
      var timestamp = new Date();
      var dispLine = evt.target.querySelector('.last-build').cloneNode(true);
      function childKiller(nodeList) {
	// Kaldes med resultatet af (element).children.
	if (!nodeList) return;
	for (var i = 0; i < nodeList.length; i++) {
	  if (nodeList[i].classList.contains('to-build')
	      && !nodeList[i].classList.contains('auto') )
	  {
	    nodeList[i].parentElement.removeChild(nodeList[i]);
	    i--; // NodeList'er kan mærke, når man hiver ting ud af dem.
	  } else if (nodeList[i].tagName.toUpperCase() === 'BR') {
	    var repSpan = document.createElement('span');
	    repSpan.textContent = '\\N';
	    nodeList[i].parentElement.replaceChild(repSpan, nodeList[i]);
	  } else {
	    childKiller(nodeList[i].childElements);
	  }
	}
      };
      
      if (dispLine.classList.contains('auto')) return;
      if (evt.target.matches('.blackout *')) {
	var pushing = { "ts": timestamp, "line": "" };
      } else {
	childKiller(dispLine.children);
	var pushing = { "ts": timestamp, "line": dispLine.textContent };
      }
      timeline.push(pushing);
      return pushing;
    };
    
    document.addEventListener("moveditem", logLine, false);

    // Den her er til lineLogDisp's information. Hvis du får brug for flere
    // states, så kom dem her ind.
    // Og måske kig på lineLogDisp...?
    logLines.possibleStates = [ "recording", "awaiting download", "stopped" ];
    logLines.setState = function setState(newState) {
      logLines.state = newState;
      lineLogDisp(logLines);
    };
    
    function llGet() {
      if (!timeline || !timeline.length || timeline.length < 2) {
	console.log("logLines.getAssFile: Sorry, nothing to see here.");
	return;
      }
      var downloadTime = logLines.endTime || new Date();
      var filestring =
	  "[Script Info]\n" +
	  "; Genereret af Kristoffers AV system.\n" +
	  "Title: Overtekster" + downloadTime.toISOString() +"\n" +
	  "ScriptType: v4.00+\n" +
	  "WrapStyle: 0\n" +
	  "ScaledBorderAndShadow: yes\n" +
	  "YCbCr Matrix: TV.601\n" +
	  "PlayResX: 1920\n" +
	  "PlayResY: 1080\n" +
	  "\n" +
	  "[V4+ Styles]\n" +
	  "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n" +
	  "Style: Overtekst,Arial,70,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1\n" +
	  "\n[Events]\n" +
	  "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n";
      var zeroTime = timeline[0].ts.getTime();
      // timeline[0].ts = downloadTime;
      var prevTime = "0:00:00.00", prevLine = "";
      // timeline.push(timeline.shift());
      timeline.push({"ts": downloadTime, "line":""});
      timeline.forEach( (line) => {
	var time = line.ts.getTime() - zeroTime;
	var timeString = "" + Math.floor(time/3600000) + ":" +
	    ("0" + Math.floor((time%3600000)/60000)).slice(-2) + ":" +
	    ("0" + Math.floor((time%60000)/1000)).slice(-2) + "." +
	    ("0" + Math.floor((time%1000)/10)).slice(-2);
	if (prevLine !== "") filestring += "Dialogue: 0," + prevTime + ","
	  + timeString + ",Overtekst,,0,0,0,,"
          + prevLine.replace(/\n/g,"\\N").replace(/\\N\s*\\N(\s*\\N)*/g,"\\N")
          + "\n";
	prevTime = timeString;
	prevLine = line.line;
      });
      timeline.pop();
      
      saveAs(new Blob([filestring]), // Fra SaveFile.min.js
             "Overtekster-" + downloadTime.toISOString() + ".ass",
	     {type: "text/plain;charset=utf-8"});
      if (logLines.endTime) {
	if (!logLines.nGets) logLines.nGets = 1; else logLines.nGets++;
      }
      if (logLines.state && logLines.state === "awaiting download")
        logLines.setState("stopped");
      logLines.start = startAgain;
    };
    logLines.getAssFile = llGet;
    logLines.setState("recording");

    function llBusy() {
      console.log("Nothing doing. logLines is currently "
                  + logLines.state.toUpperCase() + " .");
    };
    
    logLines.start = llBusy;

    function startAgain() {
      if (logTimer) clearTimeout(logTimer);
      logTimer = setTimeout(stopLogging, 43200000); // 12 timer.
      timeline = [{ "ts": new Date(), "line": ""}];
      document.addEventListener("moveditem", logLine, false);
      logLines.stop = stopLogging;
      logLines.start = llBusy;
      logLines.setState("recording");
      delete logLines.endTime;
      logLines.blank = stopLogging;
    }

    function hesitateStart() {
      if (logLine.nGets === undefined || logLine.nGets < 1) {
	// TODO: flash a warning.
	console.log("Are you sure? logLines is currently "
                    + logLines.state.toUpperCase() 
		    + " . We'll let you continue if you try again.");
	logLines.start = startAgain;
	logLines.setState("awaiting download");
      } else {
	startAgain();
      }
    };

    var logTimer = setTimeout(stopLogging, 43200000); // 12 timer.
    function stopLogging() {
      clearTimeout(logTimer);
      document.removeEventListener("moveditem", logLine);
      logLines.endTime = new Date();
      if ( timeline && timeline.length && timeline.length > 1 &&
	   (!logLines.nGets || logLines.nGets < 1) ) {
	logLines.setState("awaiting download");
	logLines.start = hesitateStart;
      } else {
	logLines.setState("stopped");
	logLines.start = startAgain;
      }
      logLines.stop = llBusy;
      logLines.blank = startAgain;
    };
    logLines.stop = stopLogging;
    blank = stopLogging;

    logLines.playButton = function playButton() {
      if (logLines.start !== llBusy) logLines.start();
      else logLines.stop();
    };
  }
};

function lineLogDisp(logger) {
  if (isRemote) {
    var lDiv = document.getElementById('log-button');
    if (lDiv) {
      if (!logger.state) {
	if (lDiv.classList.contains('control-grid')) {
	  lDiv.addEventListener('transitionend', (evt) => {
	    lDiv.textContent = '📃l';
	    lDiv.className = "";
	    lDiv.addEventListener('click', logLines, false);
	  }, {once: true, capture: false});
	  lDiv.classList.add('to-build');
	}
      } else if (!lDiv.classList.contains('control-grid')) {
	lDiv.classList.add('bounce');
	lDiv.removeEventListener('click', logLines, false);
	lDiv.addEventListener('transitionend', (evt) => {
	  lDiv.innerHTML =
	    '<div class="tl minor" id="log-tl">&#x23fa;</div>' +
	    '<div class="tr minor" id="log-tr">&#x23f9; l</div><br/>' +
	    '<div class="bl minor" id="log-bl">&#x1f4c3;</div>' +
	    '<div class="br minor" id="log-br">&#x21e9;g</div>';
	  if (logger.state.replace) {
	    logger.possibleStates.forEach( state => {
	      lDiv.classList.remove(state.toLowerCase().replace(/\s/g, "-"));
	    });
	    lDiv.classList.add("control-grid",
                               logger.state.toLowerCase().replace(/\s/g,"-"));
	    if (logger.state.toUpperCase() !== "RECORDING") {
	      lDiv.querySelector('#log-tr').textContent = "\u25ba l";
	      lDiv.querySelector('#log-tl').textContent = "\u23f9";
	    }
	  }
	  lDiv.querySelector('#log-tr')
            .addEventListener('click', logger.playButton, false);
	  lDiv.querySelector('#log-br')
            .addEventListener('click', logger.getAssFile, false);
	  lDiv.classList.remove('to-build');
          
	}, {once: true, capture: false});
        lDiv.classList.add('to-build');
      } else if (typeof logger.state === 'string') {
        
	logger.possibleStates.forEach( state => {
	  lDiv.classList.remove(state.toLowerCase().replace(/\s/g, "-"));
	});
	var cState = logger.state.toLowerCase().replace(/\s/g, "-");
	lDiv.classList.add(cState);
	var pDiv = lDiv.querySelector('#log-tr');

	if (cState === "recording") {
	  if (pDiv.textContent !== "\u23f9 l") {
	    lDiv.addEventListener('transitionend', () => {
	      pDiv.textContent = "\u23f9 l";
	      pDiv.classList.remove('to-build');
	    }, {once: true, capture: false});
	    pDiv.classList.add('to-build');
	    var sDiv = lDiv.querySelector('#log-tl');
	    lDiv.addEventListener('transitionend', () => {
	      sDiv.textContent = "\u23fa";
	      sDiv.classList.remove('to-build');
	    }, {once: true, capture: false});
	    sDiv.classList.add('to-build');
	  }
	} else {
	  if (pDiv.textContent !== "\u25ba l") {
	    pDiv.classList.add('to-build');
	    lDiv.addEventListener('transitionend', () => {
	      pDiv.textContent = "\u25ba l";
	      pDiv.classList.remove('to-build');
	    }, {once: true, capture: false});
	    var sDiv = lDiv.querySelector('#log-tl');
	    sDiv.classList.add('to-build');
	    lDiv.addEventListener('transitionend', () => {
	      sDiv.textContent = "\u23f9";
	      sDiv.classList.remove('to-build');
	    }, {once: true, capture: false});
	  }
	}
	if (cState === 'awaiting-download') {
	  var dDiv = lDiv.querySelector('#log-br');
	  dDiv.addEventListener('transitionend', () => {
	    dDiv.classList.remove('warning');
	  }, {once: true, capture: false});
	  dDiv.classList.add('warning');
	}
      }
    }
  }
};


// ## Initial function call -----------------------------------------------------
initialize();
